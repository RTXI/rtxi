/*
         The Real-Time eXperiment Interface (RTXI)
         Copyright (C) 2011 Georgia Institute of Technology, University of Utah,
   Weill Cornell Medical College

         This program is free software: you can redistribute it and/or modify
         it under the terms of the GNU General Public License as published by
         the Free Software Foundation, either version 3 of the License, or
         (at your option) any later version.

         This program is distributed in the hope that it will be useful,
         but WITHOUT ANY WARRANTY; without even the implied warranty of
         MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
         GNU General Public License for more details.

         You should have received a copy of the GNU General Public License
         along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

#include "main_window.hpp"
#include "connector.h"

// struct block_list_info_t
// {
//   QComboBox* blockList0;
//   QComboBox* blockList1;
//   std::vector<IO::Block*>* blocks;
// };

// static void buildBlockList(IO::Block* block, void* arg)
// {
//   block_list_info_t* info = static_cast<block_list_info_t*>(arg);
//   info->blockList0->addItem(QString::fromStdString(block->getName()) + " "
//                             + QString::number(block->getID()));
//   info->blockList1->addItem(QString::fromStdString(block->getName()) + " "
//                             + QString::number(block->getID()));
//   info->blocks->push_back(block);
// }

Connector::Panel::Panel(MainWindow* mw, Event::Manager* event_manager)
    : Modules::Panel(std::string(Connector::MODULE_NAME), mw, event_manager)
{
  setWhatsThis(
      "<p><b>Connector:</b><br>The Connector panel allows you to make "
      "connections between "
      "signals and slots in your workspace. Signals are generated by the DAQ "
      "card (associated "
      "with input channels) and by user modules. Available signals are listed "
      "in the \"Output "
      "Block\" drop-down box and available slots are listed in the \"Input "
      "Block\" drop-down box. "
      "The arrow button is a toggle button that turns connections on and off. "
      "Clicking the toggle "
      "button immediately makes a connection active or inactive in real-time. "
      "Current connections "
      "are listed in the \"Connections\" box.</p>");

  // Make Mdi
  subWindow = new QMdiSubWindow;
  subWindow->setWindowIcon(QIcon("/usr/local/share/rtxi/RTXI-widget-icon.png"));
  subWindow->setAttribute(Qt::WA_DeleteOnClose);
  subWindow->setWindowFlags(Qt::CustomizeWindowHint | Qt::WindowCloseButtonHint
                            | Qt::WindowMinimizeButtonHint);
  this->getMainWindowPtr()->createMdi(subWindow);

  // Create main layout
  QGridLayout* layout = new QGridLayout;

  // Create child widget and layout for output block
  outputGroup = new QGroupBox(tr("Source"));
  QVBoxLayout* outputLayout = new QVBoxLayout;

  // Create elements for output
  outputLayout->addWidget(new QLabel(tr("Block:")), 1, 0);
  outputBlock = new QComboBox;
  outputLayout->addWidget(outputBlock);
  QObject::connect(outputBlock,
                   SIGNAL(activated(int)),
                   this,
                   SLOT(buildOutputChannelList(void)));

  outputLayout->addWidget(new QLabel(tr("Channel:")), 2, 0);
  outputChannel = new QComboBox;
  outputLayout->addWidget(outputChannel);
  QObject::connect(outputChannel,
                   SIGNAL(activated(int)),
                   this,
                   SLOT(updateConnectionButton(void)));

  // Assign layout to child widget
  outputGroup->setLayout(outputLayout);

  // Create child widget and layout for connection button
  buttonGroup = new QGroupBox;
  QVBoxLayout* buttonLayout = new QVBoxLayout;

  // Create elements for button
  connectionButton = new QPushButton("Connect");
  connectionButton->setCheckable(true);
  buttonLayout->addWidget(connectionButton);
  QObject::connect(connectionButton,
                   SIGNAL(toggled(bool)),
                   this,
                   SLOT(toggleConnection(bool)));

  // Assign layout to child widget
  buttonGroup->setLayout(buttonLayout);

  // Create child widget and layout for input block
  inputGroup = new QGroupBox(tr("Destination"));
  QVBoxLayout* inputLayout = new QVBoxLayout;

  // Create elements for output
  inputLayout->addWidget(new QLabel(tr("Block:")), 1, 0);
  inputBlock = new QComboBox;
  inputLayout->addWidget(inputBlock);
  QObject::connect(inputBlock,
                   SIGNAL(activated(int)),
                   this,
                   SLOT(buildInputChannelList(void)));

  inputLayout->addWidget(new QLabel(tr("Channel:")), 2, 0);
  inputChannel = new QComboBox;
  inputLayout->addWidget(inputChannel);
  QObject::connect(inputChannel,
                   SIGNAL(activated(int)),
                   this,
                   SLOT(updateConnectionButton(void)));

  // Assign layout to child widget
  inputGroup->setLayout(inputLayout);

  // Create child widget and layout for connections box
  connectionGroup = new QGroupBox(tr("Connections"));
  QVBoxLayout* connectionLayout = new QVBoxLayout;

  // Create elements for connection box
  connectionBox = new QListWidget;
  connectionLayout->addWidget(connectionBox);
  QObject::connect(connectionBox,
                   SIGNAL(itemClicked(QListWidgetItem*)),
                   this,
                   SLOT(highlightConnectionBox(QListWidgetItem*)));

  // Assign layout to child widget
  connectionGroup->setLayout(connectionLayout);

  // Attach child widget to parent widget
  layout->addWidget(outputGroup, 1, 0, 1, 2);
  layout->addWidget(buttonGroup, 2, 0, 1, 4);
  layout->addWidget(inputGroup, 1, 2, 1, 2);
  layout->addWidget(connectionGroup, 3, 0, 1, 4);

  // Set layout so that only connectionGroup expands when resized
  layout->setRowStretch(0, 0);
  layout->setRowStretch(2, 0);
  layout->setRowStretch(3, 1);

  // Attach layout to widget
  setLayout(layout);
  setWindowTitle(QString::fromStdString(this->getName()));

  // Set layout to Mdi
  subWindow->setWidget(this);
  subWindow->resize(500, subWindow->sizeHint().height());
  show();

  // populate field with block and connection info
  this->syncBlockInfo();

  QObject::connect(this, SIGNAL(updateBlockInfo(void)), this, SLOT(syncBlockInfo(void)));
}

void Connector::Panel::buildBlockList()
{
  inputBlock->clear();
  outputBlock->clear();
  Event::Object event(Event::Type::IO_BLOCK_QUERY_EVENT);
  this->getRTXIEventManager()->postEvent(&event);
  this->blocks = std::any_cast<std::vector<IO::Block*>>(event.getParam("blockList"));
  for(auto block : this->blocks){
    this->inputBlock->addItem(QString::fromStdString(block->getName()) + " " + 
                              QString::number(block->getID()));
    this->outputBlock->addItem(QString::fromStdString(block->getName()) + " " + 
                               QString::number(block->getID()));
  }
}

void Connector::Panel::buildConnectionList()
{
  Event::Object event(Event::Type::IO_ALL_CONNECTIONS_QUERY_EVENT);
  this->getRTXIEventManager()->postEvent(&event);
  this->links = 
    std::any_cast<std::vector<RT::block_connection_t>>(event.getParam("connections"));
}

void Connector::Plugin::receiveEvent(Event::Object* event)
{
  switch (event->getType()) {
    case Event::Type::RT_THREAD_INSERT_EVENT:
    case Event::Type::RT_THREAD_REMOVE_EVENT:
    case Event::Type::RT_DEVICE_INSERT_EVENT:
    case Event::Type::RT_DEVICE_REMOVE_EVENT:
    case Event::Type::IO_LINK_INSERT_EVENT:
    case Event::Type::IO_LINK_REMOVE_EVENT:
      this->updatePanelInfo();
      break;
    default:
      break;
  }
}

void Connector::Plugin::updatePanelInfo()
{
  dynamic_cast<Connector::Panel*>(this->widget_panel)->updateBlockInfo();
}

// This slot will be called by the plugin to update block list and connection
// info after a block has been inserted. The update will show up in the panel
void Connector::Panel::syncBlockInfo()
{
  this->buildBlockList();
  this->buildConnectionList();

  if (!blocks.empty()) {
    this->buildInputChannelList();
    this->buildOutputChannelList();
  }

  connectionBox->clear();
  for (auto conn : this->links) {
    connectionBox->addItem(QString::number(conn.src->getID()) + " "
                           + QString::fromStdString(conn.src->getName())
                           + " : " + QString::number(conn.src_port) + " "
                           + QString::fromStdString(conn.src->getChannelName(
                               IO::OUTPUT, conn.src_port))
                           + " ==> " + QString::number(conn.dest->getID())
                           + " "
                           + QString::fromStdString(conn.dest->getName())
                           + " : " + QString::number(conn.dest_port) + " "
                           + QString::fromStdString(conn.dest->getChannelName(
                               IO::INPUT, conn.dest_port)));
  }
}

void Connector::Panel::buildInputChannelList()
{
  inputChannel->clear();
  if (!inputBlock->count())
    return;

  // Get specific block
  IO::Block* block = blocks[inputBlock->currentIndex()];

  // Get list of channels from specific block
  for (size_t i = 0; i < block->getCount(IO::INPUT); ++i)
    inputChannel->addItem(QString::fromStdString(block->getChannelName(IO::INPUT, i)));

  updateConnectionButton();
}

void Connector::Panel::buildOutputChannelList(void)
{
  outputChannel->clear();
  if (!outputBlock->count())
    return;

  // Get specific block
  IO::Block* block = blocks[outputBlock->currentIndex()];

  // Get list of channels from specific block
  for (size_t i = 0; i < block->getCount(IO::OUTPUT); ++i)
    outputChannel->addItem(
        QString::fromStdString(block->getChannelName(IO::OUTPUT, i)));

  updateConnectionButton();
}

void Connector::Panel::highlightConnectionBox(QListWidgetItem* item)
{
  int link_index = this->connectionBox->selectionModel()->selectedIndexes()[0].row();
  if (link_index < 0 || link_index >= this->links.size()) { return; }

  // Find out selected src block
  IO::Block* src = this->links[static_cast<size_t>(link_index)].src;
  auto src_iter = std::find(this->blocks.begin(), this->blocks.end(), src);
  int src_index = -1;
  if (src_iter != this->blocks.end()) {
    src_index = static_cast<int>(std::distance(this->blocks.begin(), src_iter));
  }

  // build info in the output group
  this->outputBlock->setCurrentIndex(src_index);
  buildOutputChannelList();
  size_t src_port= this->links[static_cast<size_t>(link_index)].src_port;
  outputChannel->setCurrentIndex(static_cast<int>(src_port));

  // find out selected dest block
  IO::Block* dest = this->links[static_cast<size_t>(link_index)].dest;
  auto dest_iter = std::find(this->blocks.begin(), this->blocks.end(), dest);
  int dest_index = -1;
  if (dest_iter != this->blocks.end()) {
    dest_index = static_cast<int>(std::distance(this->blocks.begin(), dest_iter));
  }

  // build info in the input group
  this->inputBlock->setCurrentIndex(dest_index);
  buildInputChannelList();
  size_t dest_port= this->links[static_cast<size_t>(link_index)].dest_port;
  inputChannel->setCurrentIndex(static_cast<int>(dest_port));

  // update connection button state
  updateConnectionButton();
}

void Connector::Panel::toggleConnection(bool on)
{
  RT::block_connection_t connection;
  int src_id = outputBlock->currentIndex();
  int dest_id = inputBlock->currentIndex();
  int src_port_id = outputChannel->currentIndex();
  int dest_port_id = inputChannel->currentIndex();

  // If no valid selection then do nothing
  if(src_id == -1 || dest_id == -1 || src_port_id == -1 || dest_port_id == -1){
    this->connectionButton->setDown(false);
    return;
  }

  connection.src = blocks[static_cast<size_t>(src_id)];
  connection.dest = blocks[static_cast<size_t>(dest_id)];
  connection.src_port = static_cast<size_t>(src_port_id);
  connection.dest_port = static_cast<size_t>(dest_port_id);
  
  //if (IO::Connector::getInstance()->connected(src, src_num, dest, dest_num)
  //    == on)
  //  return;

  if (on) {
    Event::Object event(Event::Type::IO_LINK_INSERT_EVENT);
    event.setParam("connection", std::any(connection));
    this->getRTXIEventManager()->postEvent(&event);
  } else {
    Event::Object event(Event::Type::IO_LINK_REMOVE_EVENT);
    event.setParam("connection", std::any(connection));
    this->getRTXIEventManager()->postEvent(&event);
  }
}

void Connector::Panel::updateConnectionButton()
{
  if (inputChannel->count() == 0 || outputChannel->count() == 0) {
    connectionButton->setEnabled(false);
  } else {
    connectionButton->setEnabled(true);
    IO::Block* src = blocks[outputBlock->currentIndex()];
    IO::Block* dest = blocks[inputBlock->currentIndex()];
    size_t src_num = outputChannel->currentIndex();
    size_t dest_num = inputChannel->currentIndex();

    auto iter = std::find_if(this->links.begin(),
                             this->links.end(),
                             [&](RT::block_connection_t registered_conn) {
                               return registered_conn.src == src &&
                                      registered_conn.src_port == src_num &&
                                      registered_conn.dest == dest &&
                                      registered_conn.dest_port == dest_num;});
    connectionButton->setChecked(iter != this->links.end());
  }
}

Connector::Plugin::Plugin(Event::Manager* ev_manager, MainWindow* mw) 
  : Modules::Plugin(ev_manager, mw, std::string(Connector::MODULE_NAME))
{
}

std::unique_ptr<Modules::Plugin> Connector::createRTXIPlugin(
    Event::Manager* ev_manager, MainWindow* main_window)
{
  return std::make_unique<Connector::Plugin>(ev_manager, main_window);
}

Modules::Panel* Connector::createRTXIPanel(
    MainWindow* main_window, Event::Manager* ev_manager)
{
  return static_cast<Modules::Panel*>(new Connector::Panel(
      main_window,
      ev_manager));
}

std::unique_ptr<Modules::Component> Connector::createRTXIComponent(
    Modules::Plugin* )
{
  return std::unique_ptr<Modules::Component>(nullptr);
}

Modules::FactoryMethods Connector::getFactories()
{
  Modules::FactoryMethods fact;
  fact.createPanel = &Connector::createRTXIPanel;
  fact.createComponent = &Connector::createRTXIComponent;
  fact.createPlugin = &Connector::createRTXIPlugin;
  return fact;
}
